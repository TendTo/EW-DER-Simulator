\chapter{Smart Contract: ExamContract}

Per la realizzazione dello \gls{smart-contract}, è stata utilizzata la piattaforma \gls{ewc}.
Il contratto è stato scritto in Solidity, il linguaggio di programmazione orientato agli oggetti, più diffuso per l'implementazione di contratti su varie piattaforme blockchain tra cui Ethereum. \\

\section{Funzionalità}
Lo \gls{smart-contract} ha come scopo quello di tenere traccia del bilancio di tutti i \gls{prosumer} che fanno riferimento all'\gls{aggregator} che lo ha rilasciato su \gls{ewc}. \\
Ogni \gls{prosumer} sottoscrive un \gls{agreement} con l'\gls{aggregator}, stabilendo i termini della loro collaborazione.
Sono parte di questo accordo la fonte energetica utilizzata, la quantità di energia prodotta e il suo prezzo, e la flessibilità che il \gls{prosumer} è in grado di fornire. \\
In qualsiasi momento il \gls{prosumer} è in grado di avviare un evento di flessibilità.
L'\gls{event-log} emesso nel momento in cui il metodo predisposto viene invocato avvisa tutti i \gls{der} della richiesta,
ed ognuno di essi reagirà a quest'ultima nei termini del proprio \gls{agreement}. \\
Ogni richiesta è caratterizzata dai seguenti valori:
\begin{itemize}
  \item \textbf{Flessibilità:} variazione che la rete deve produrre rispetto alla \gls{baseline}
  \item \textbf{Inizio:} limite di tempo entro il quale tutti i \gls{der} devono raggiungere il valore di flessibilità richiesto
  \item \textbf{Fine:} fine del periodo di flessibilità. Dal momento indicato, i \gls{der} hanno 15 minuti per tornare alla baseline
\end{itemize}
Non ci possono essere due richieste di flessibilità contemporanee.

\section{Sviluppo dello smart contract}

Lo sviluppo dello smart contract è stato realizzato utilizzando una pletora di framework e librerie open source.

\subsection{Strumenti di sviluppo}

Lo sviluppo dello \gls{smart-contract} si è svolto in locale, utilizzando il framework hardhat \cite{sftw:hardhat}.
Si tratta di un ambiente di sviluppo per \gls{smart-contract} dotato di moltissimi componenti
che consentono di svolgere operazioni come il debugging, la compilazione e il testing di \gls{smart-contract}. \\
Una feature aggiuntiva realizzata dal plugin \href{https://www.npmjs.com/package/@typechain/hardhat}{@typechain/hardhat} \cite{sftw:typechain_hardhat} è la creazione automatica di
classi proxy e funzioni che descrivono accuratamente i metodi dello \gls{smart-contract},
che è poi possibile importare ed utilizzare in qualsiasi file typescript, semplificando l'interazione con lo \gls{smart-contract}. \\
\\
hardhat si occupa anche del deployment dello \gls{smart-contract} su \gls{ewc}. \\
Fornendo una chiave privata associata ad un account con sufficiente credito e un nodo \gls{rpc-api} a cui collegarsi,
è estremamente facile realizzare un semplice script (\autoref{cod:deployment}) che si occupi di distribuire lo \gls{smart-contract} sulla blockchain scelta.

\inputminted{typescript}{../contracts/scripts/deployAggregatorContract.ts}
\captionof{listing}{Script che si occupa del deployment dello \gls{smart-contract} su \gls{ewc} \label{cod:deployment}}

\subsection{Test}

Il framework utilizzato mette a disposizione anche una serie di metodologie per poter testare facilmente e velocemente lo \gls{smart-contract}. \\
Utilizzando un'apposita estensione della libreria chai \cite{sftw:chai}, combinata con una blockchain simulata in locale da hardhat
è possibile effettuare il deploy dello \gls{smart-contract} e verificare che tutti i suoi metodi si comportino come previsto. \\
I test variano dal controllo del valore di ritorno del metodo invocato, al verificare che lo stato del contratto sia stato alterato nella maniera corretta,
e anche assicurarsi che venga prodotta l'eccezione prevista su input invalidi. \\
Mettendo insieme tutti i test, è stata raggiunta una \href{https://app.codecov.io/gh/TendTo/EW-DER-Simulator}{notevole copertura} del codice \footnote{https://app.codecov.io/gh/TendTo/EW-DER-Simulator}. \\
\\
Segue qualche esempio di test utilizzato:
\begin{minted}{typescript}
describe("requestFlexibility", function () {

  it("create a new flexibility request", async function () {
 await contract.requestFlexibility(start, end, gridFlexibility);
 const request = await contract.flexibilityRequest();
 expect(request.start.toNumber()).to.equal(start);
 expect(request.end.toNumber()).to.equal(end);
 expect(request.gridFlexibility.toNumber()).to.equal(gridFlexibility);
  });

  it("revert on unauthorized use with 'UnauthorizedAggregatorError(msg.sender)'", async function () {
 await expect(iot1Contract.requestFlexibility(start, end, gridFlexibility))
   .to.be.revertedWithCustomError(contract, ContractError.UnauthorizedAggregatorError)
   .withArgs(iot1Addr);
  });
});
\end{minted}

\section{Strutture dati}

Per la gestione dei dati all'interno della blockchain lo \gls{smart-contract} utilizza un approccio ibrido. \\
Viene salvato in maniera persistente, e quindi occupa spazio di archiviazione nel contratto, solo ciò di cui lo stesso ha bisogno per
svolgere i controlli di validazione previsti. \\
Al contrario, tutto il resto viene reso pubblico ed immutabile attraverso lo strumento degli \gls{event-log},
emessi nel momento in cui avviene l'evento corrispondente. \\
Questo approccio è più economico rispetto allo storage tradizionale, il contratto non è in grado di consultare gli \gls{event-log} emessi in precedenza. \\
\\
Lo storage tradizionale è utilizzato per le strutture dati:
\begin{minted}{solidity}
// Address that deployed the contract. Represents the aggregator
address public immutable aggregator;
// Current aggregated baseline provided by all the DERs 
int256 public energyBalance;
// State of the prosumer, like its balance and reputation
mapping(address => Prosumer) public prosumers;
// Mapping between each prosumer and its agreement
mapping(address => Agreement) public agreements;
// List of prosumers that registered an agreement. 
// Used if they are all to be rewarded
address[] public prosumerList;
// Structure that contains the flexibility request data
FlexibilityRequest public flexibilityRequest;
// Flexibility result for each DER, provided by the aggregator
mapping(address => int256) public flexibilityResults;
\end{minted}

Gli eventi previsti sono:
\begin{minted}[fontsize=\footnotesize]{solidity}
event RegisterAgreement(address indexed prosumer, Agreement agreement);
event ReviseAgreement(address indexed prosumer, Agreement oldAgreement, Agreement newAgreement);
event CancelAgreement(address indexed prosumer, Agreement agreement);
event RequestFlexibility(uint256 indexed start, uint256 indexed stop, int256 gridFlexibility);
event EndRequestFlexibility(uint256 indexed start, uint256 indexed stop, int256 gridFlexibility);
event FlexibilityProvisioningSuccess(uint256 indexed start, address indexed prosumer, int256 flexibility, int256 reward);
event FlexibilityProvisioningError(uint256 indexed start, address indexed prosumer, int256 flexibilityFromAggregator, int256 flexibilityFromProsumer, int256 expectedFlexibility);
event RewardProduction(address indexed prosumer, uint256 indexed timestamp, int256 value, int256 reward);
\end{minted}

\section{Metodi principali}

Di seguito sono elencati i metodi principali e il loro funzionamento.
% \captionof{listing}{Metodo chiamato da un \gls{prosumer} che intende registrare un agreement con l'\gls{aggregator} \label{cod:registerAgreement}}
\begin{minted}[fontsize=\footnotesize]{solidity}
function registerAgreement(Agreement calldata _agreement) external
\end{minted}